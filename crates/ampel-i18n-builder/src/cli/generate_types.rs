//! GenerateTypes command implementation - generates TypeScript type definitions.

use crate::cli::GenerateTypesArgs;
use crate::error::Result;
use crate::formats::{JsonFormat, TranslationFormat, TranslationValue};
use colored::Colorize;
use std::collections::BTreeMap;
use std::fs;
use std::io::Write;
use std::path::PathBuf;

pub async fn execute(args: GenerateTypesArgs) -> Result<()> {
    println!(
        "{} Generating TypeScript types from translations",
        "→".cyan().bold()
    );

    // Load source (English) translations
    let source_dir = args.translation_dir.join("en");
    if !source_dir.exists() {
        return Err(crate::error::Error::Io(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("Source directory not found: {}", source_dir.display()),
        )));
    }

    let format = JsonFormat::new();
    let namespaces = load_namespaces(&source_dir, &format)?;

    // Discover available languages
    let languages = discover_languages(&args.translation_dir)?;

    // Generate TypeScript content
    let ts_content = generate_typescript(&namespaces, &languages);

    // Write to output file
    if let Some(parent) = args.output.parent() {
        fs::create_dir_all(parent)?;
    }

    let mut file = fs::File::create(&args.output)?;
    file.write_all(ts_content.as_bytes())?;

    println!(
        "{} Generated TypeScript types at {}",
        "✓".green().bold(),
        args.output.display()
    );

    Ok(())
}

fn load_namespaces(
    dir: &PathBuf,
    format: &JsonFormat,
) -> Result<BTreeMap<String, BTreeMap<String, TranslationValue>>> {
    let mut namespaces = BTreeMap::new();

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|e| e.to_str()) == Some("json") {
            if let Some(name) = path.file_stem().and_then(|n| n.to_str()) {
                let content = fs::read_to_string(&path)?;
                let map = format.parse(&content)?;
                namespaces.insert(name.to_string(), map);
            }
        }
    }

    Ok(namespaces)
}

fn discover_languages(translation_dir: &PathBuf) -> Result<Vec<String>> {
    let mut languages = Vec::new();

    if !translation_dir.exists() {
        return Ok(languages);
    }

    for entry in fs::read_dir(translation_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            if let Some(lang) = path.file_name().and_then(|n| n.to_str()) {
                if !lang.starts_with('.') {
                    languages.push(lang.to_string());
                }
            }
        }
    }

    languages.sort();
    Ok(languages)
}

fn generate_typescript(
    namespaces: &BTreeMap<String, BTreeMap<String, TranslationValue>>,
    languages: &[String],
) -> String {
    let mut output = String::new();

    // Header
    output.push_str("// Auto-generated by ampel-i18n-builder\n");
    output.push_str("// Do not edit manually\n\n");

    // Supported languages type
    output.push_str("export type SupportedLanguage =\n");
    for (i, lang) in languages.iter().enumerate() {
        if i == languages.len() - 1 {
            output.push_str(&format!("  | '{}';\n\n", lang));
        } else {
            output.push_str(&format!("  | '{}'\n", lang));
        }
    }

    // Default language
    output.push_str("export const defaultLanguage: SupportedLanguage = 'en';\n\n");

    // Supported languages array
    output.push_str("export const supportedLanguages: SupportedLanguage[] = [\n");
    for lang in languages {
        output.push_str(&format!("  '{}',\n", lang));
    }
    output.push_str("];\n\n");

    // Namespace types
    output.push_str("export type TranslationNamespace =\n");
    let ns_keys: Vec<_> = namespaces.keys().collect();
    for (i, ns) in ns_keys.iter().enumerate() {
        if i == ns_keys.len() - 1 {
            output.push_str(&format!("  | '{}';\n\n", ns));
        } else {
            output.push_str(&format!("  | '{}'\n", ns));
        }
    }

    // Generate type for each namespace
    for (ns_name, translations) in namespaces {
        let type_name = to_pascal_case(ns_name);
        output.push_str(&format!("export interface {}Translations {{\n", type_name));
        generate_interface_fields(translations, &mut output, 1);
        output.push_str("}\n\n");
    }

    // Combined translations type
    output.push_str("export interface Translations {\n");
    for ns_name in namespaces.keys() {
        let type_name = to_pascal_case(ns_name);
        output.push_str(&format!("  {}: {}Translations;\n", ns_name, type_name));
    }
    output.push_str("}\n");

    output
}

fn generate_interface_fields(
    map: &BTreeMap<String, TranslationValue>,
    output: &mut String,
    indent: usize,
) {
    let indent_str = "  ".repeat(indent);

    for (key, value) in map {
        let safe_key = if needs_quoting(key) {
            format!("'{}'", key)
        } else {
            key.clone()
        };

        match value {
            TranslationValue::String(_) => {
                output.push_str(&format!("{}{}: string;\n", indent_str, safe_key));
            }
            TranslationValue::Plural(_) => {
                output.push_str(&format!("{}{}: string;\n", indent_str, safe_key));
            }
            TranslationValue::Nested(nested) => {
                output.push_str(&format!("{}{}: {{\n", indent_str, safe_key));
                generate_interface_fields(nested, output, indent + 1);
                output.push_str(&format!("{}}};\n", indent_str));
            }
        }
    }
}

fn needs_quoting(key: &str) -> bool {
    key.contains('-') || key.contains('.') || key.chars().next().is_some_and(|c| c.is_ascii_digit())
}

fn to_pascal_case(s: &str) -> String {
    s.split(['-', '_'])
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}
