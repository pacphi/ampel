//! TypeScript type definition generator
//!
//! Generates TypeScript type definitions for type-safe translation functions.

use super::*;
use async_trait::async_trait;
use std::collections::BTreeMap;
use std::path::Path;

/// TypeScript code generator
pub struct TypeScriptGenerator;

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self
    }

    /// Generate TypeScript interface from translation map
    pub fn generate_types(
        &self,
        translations: &TranslationMap,
        language: &str,
        options: &GeneratorOptions,
    ) -> String {
        let mut output = String::new();

        // Header comment
        if options.include_metadata {
            output.push_str(&format!(
                "// Generated by ampel-i18n-builder\n\
                 // Language: {}\n\
                 // Generated at: {}\n\
                 // DO NOT EDIT - This file is auto-generated\n\n",
                language,
                chrono::Utc::now()
            ));
        }

        // Generate namespace interface
        output.push_str("/**\n");
        output.push_str(&format!(" * Translation keys for {} language\n", language));
        output.push_str(" */\n");

        // Build the type structure
        let type_structure = self.build_type_structure(translations);
        output.push_str(&self.render_interface("Translations", &type_structure, 0));

        // Generate helper types for type-safe key access
        output.push_str("\n/**\n");
        output.push_str(" * Extract paths to string properties in nested object\n");
        output.push_str(" */\n");
        output.push_str("export type PathsToStringProps<T> = T extends string\n");
        output.push_str("  ? []\n");
        output.push_str("  : {\n");
        output.push_str("      [K in Extract<keyof T, string>]: T[K] extends string\n");
        output.push_str("        ? [K]\n");
        output.push_str("        : T[K] extends object\n");
        output.push_str("        ? [K, ...PathsToStringProps<T[K]>]\n");
        output.push_str("        : never;\n");
        output.push_str("    }[Extract<keyof T, string>];\n\n");

        // Generate translation key union type
        output.push_str("/**\n");
        output.push_str(" * All valid translation keys with dot notation\n");
        output.push_str(" */\n");
        output.push_str(
            "export type TranslationKey = Join<PathsToStringProps<Translations>, '.'>;\n\n",
        );

        // Join helper type
        output.push_str("type Join<T extends string[], D extends string> =\n");
        output.push_str("  T extends [] ? never :\n");
        output.push_str("  T extends [infer F] ? F :\n");
        output.push_str("  T extends [infer F, ...infer R]\n");
        output.push_str("    ? F extends string\n");
        output.push_str("      ? `${F}${D}${Join<Extract<R, string[]>, D>}`\n");
        output.push_str("      : never\n");
        output.push_str("    : string;\n\n");

        // Generate the translation function type
        output.push_str("/**\n");
        output.push_str(" * Type-safe translation function signature\n");
        output.push_str(" */\n");
        output.push_str("export type TranslateFn = (\n");
        output.push_str("  key: TranslationKey,\n");
        output.push_str("  params?: Record<string, string | number>\n");
        output.push_str(") => string;\n");

        output
    }

    /// Build TypeScript type structure from translation map
    fn build_type_structure(&self, translations: &TranslationMap) -> TypeStructure {
        let mut structure = TypeStructure::Object(BTreeMap::new());

        for (key, value) in translations {
            self.insert_into_structure(&mut structure, key, value);
        }

        structure
    }

    /// Insert a translation value into the type structure
    fn insert_into_structure(
        &self,
        structure: &mut TypeStructure,
        key: &str,
        value: &TranslationValue,
    ) {
        if let TypeStructure::Object(ref mut map) = structure {
            match value {
                TranslationValue::String(_) => {
                    map.insert(key.to_string(), TypeStructure::String);
                }
                TranslationValue::Plural(_) => {
                    map.insert(key.to_string(), TypeStructure::String);
                }
                TranslationValue::Nested(nested) => {
                    let mut nested_structure = TypeStructure::Object(BTreeMap::new());
                    for (nested_key, nested_value) in nested {
                        self.insert_into_structure(&mut nested_structure, nested_key, nested_value);
                    }
                    map.insert(key.to_string(), nested_structure);
                }
            }
        }
    }

    /// Render TypeScript interface from type structure
    fn render_interface(&self, name: &str, structure: &TypeStructure, indent: usize) -> String {
        let mut output = String::new();
        let indent_str = "  ".repeat(indent);

        match structure {
            TypeStructure::String => {
                output.push_str("string");
            }
            TypeStructure::Object(map) => {
                output.push_str(&format!("export interface {} {{\n", name));
                for (key, value) in map {
                    let sanitized_key = if is_valid_identifier(key) {
                        key.clone()
                    } else {
                        format!("\"{}\"", key)
                    };

                    match value {
                        TypeStructure::String => {
                            output
                                .push_str(&format!("{}  {}: string;\n", indent_str, sanitized_key));
                        }
                        TypeStructure::Object(nested_map) => {
                            output.push_str(&format!("{}  {}: {{\n", indent_str, sanitized_key));
                            for (nested_key, nested_value) in nested_map {
                                let nested_sanitized = if is_valid_identifier(nested_key) {
                                    nested_key.clone()
                                } else {
                                    format!("\"{}\"", nested_key)
                                };
                                let type_str = self.render_type(nested_value, indent + 2);
                                output.push_str(&format!(
                                    "{}    {}: {};\n",
                                    indent_str, nested_sanitized, type_str
                                ));
                            }
                            output.push_str(&format!("{}  }};\n", indent_str));
                        }
                    }
                }
                output.push_str(&format!("{}}}\n", indent_str));
            }
        }

        output
    }

    /// Render a TypeScript type from type structure
    fn render_type(&self, structure: &TypeStructure, indent: usize) -> String {
        let indent_str = "  ".repeat(indent);

        match structure {
            TypeStructure::String => "string".to_string(),
            TypeStructure::Object(map) => {
                let mut output = String::from("{\n");
                for (key, value) in map {
                    let sanitized_key = if is_valid_identifier(key) {
                        key.clone()
                    } else {
                        format!("\"{}\"", key)
                    };
                    let type_str = self.render_type(value, indent + 1);
                    output.push_str(&format!(
                        "{}  {}: {};\n",
                        indent_str, sanitized_key, type_str
                    ));
                }
                output.push_str(&format!("{}}}", indent_str));
                output
            }
        }
    }
}

#[async_trait]
impl CodeGenerator for TypeScriptGenerator {
    async fn generate(
        &self,
        translations: &TranslationMap,
        language: &str,
        output_dir: &Path,
        options: GeneratorOptions,
    ) -> Result<GeneratorResult, GeneratorError> {
        let mut files_created = Vec::new();
        let keys_written = flatten_translations(translations).len() as u32;

        // Create output directory if it doesn't exist
        std::fs::create_dir_all(output_dir)?;

        // Generate types file
        let types_content = self.generate_types(translations, language, &options);
        let types_file = output_dir.join("types.ts");
        std::fs::write(&types_file, types_content)?;
        files_created.push(types_file);

        // Generate index file if requested
        if options.create_index {
            let index_content = "// Generated by ampel-i18n-builder\nexport * from './types';\n";
            let index_file = output_dir.join("index.ts");
            std::fs::write(&index_file, index_content)?;
            files_created.push(index_file);
        }

        Ok(GeneratorResult {
            files_created,
            languages_processed: 1,
            keys_written,
        })
    }

    fn file_extension(&self) -> &str {
        "ts"
    }

    fn language_name(&self) -> &str {
        "TypeScript"
    }
}

/// TypeScript type structure
#[derive(Debug, Clone)]
enum TypeStructure {
    String,
    Object(BTreeMap<String, TypeStructure>),
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_translations() -> TranslationMap {
        let mut translations = BTreeMap::new();
        translations.insert(
            "hello".to_string(),
            TranslationValue::String("Hello".to_string()),
        );

        let mut common = BTreeMap::new();
        common.insert(
            "welcome".to_string(),
            TranslationValue::String("Welcome".to_string()),
        );
        translations.insert("common".to_string(), TranslationValue::Nested(common));

        translations
    }

    #[tokio::test]
    async fn test_typescript_generator() {
        let generator = TypeScriptGenerator::new();
        let translations = create_test_translations();
        let output_dir = PathBuf::from("/tmp/ampel-i18n-ts-test");

        let options = GeneratorOptions::default();
        let result = generator
            .generate(&translations, "en", &output_dir, options)
            .await;

        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.languages_processed, 1);
        assert!(result.keys_written >= 2);
        assert!(!result.files_created.is_empty());

        // Cleanup
        let _ = std::fs::remove_dir_all(&output_dir);
    }

    #[test]
    fn test_generate_types() {
        let generator = TypeScriptGenerator::new();
        let translations = create_test_translations();
        let options = GeneratorOptions {
            include_metadata: false,
            ..Default::default()
        };

        let types = generator.generate_types(&translations, "en", &options);
        assert!(types.contains("export interface Translations"));
        assert!(types.contains("hello: string"));
        assert!(types.contains("common:"));
        assert!(types.contains("export type TranslateFn"));
    }

    #[test]
    fn test_build_type_structure() {
        let generator = TypeScriptGenerator::new();
        let mut translations = BTreeMap::new();
        translations.insert(
            "test".to_string(),
            TranslationValue::String("Test".to_string()),
        );

        let structure = generator.build_type_structure(&translations);
        match structure {
            TypeStructure::Object(map) => {
                assert_eq!(map.len(), 1);
                assert!(matches!(map.get("test"), Some(TypeStructure::String)));
            }
            _ => panic!("Expected object structure"),
        }
    }
}
