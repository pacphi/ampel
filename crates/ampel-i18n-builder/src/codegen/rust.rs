//! Rust const declaration generator
//!
//! Generates Rust const declarations for compile-time translation key validation.

use super::*;
use async_trait::async_trait;
use std::collections::BTreeMap;
use std::path::Path;

/// Rust code generator
pub struct RustGenerator;

impl Default for RustGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl RustGenerator {
    pub fn new() -> Self {
        Self
    }

    /// Generate Rust const declarations from translation map
    pub fn generate_consts(&self, translations: &TranslationMap, language: &str, options: &GeneratorOptions) -> String {
        let mut output = String::new();

        // Header comment
        if options.include_metadata {
            output.push_str(&format!(
                "// Generated by ampel-i18n-builder\n\
                 // Language: {}\n\
                 // Generated at: {}\n\
                 // DO NOT EDIT - This file is auto-generated\n\n",
                language, chrono::Utc::now()
            ));
        }

        // Module declaration
        output.push_str("#![allow(dead_code)]\n");
        output.push_str("#![allow(non_upper_case_globals)]\n\n");

        output.push_str("//! Translation keys for compile-time validation\n");
        output.push_str("//!\n");
        output.push_str(&format!("//! Language: {}\n", language));
        output.push_str("//! \n");
        output.push_str("//! Use these constants with `rust_i18n::t!()` macro for type-safe translations.\n\n");

        // Generate const declarations
        let flattened = flatten_translations(translations);
        let consts = self.generate_const_declarations(&flattened);
        output.push_str(&consts);

        // Generate namespace modules if requested
        if options.split_by_namespace {
            output.push('\n');
            output.push_str(&self.generate_namespace_modules(translations));
        }

        // Generate helper macro
        output.push_str("\n/// Helper macro for type-safe translations\n");
        output.push_str("/// \n");
        output.push_str("/// # Example\n");
        output.push_str("/// ```\n");
        output.push_str("/// use crate::i18n::keys::*;\n");
        output.push_str("/// let welcome = t!(COMMON_WELCOME);\n");
        output.push_str("/// ```\n");
        output.push_str("#[macro_export]\n");
        output.push_str("macro_rules! t {\n");
        output.push_str("    ($key:expr) => {\n");
        output.push_str("        rust_i18n::t!($key)\n");
        output.push_str("    };\n");
        output.push_str("    ($key:expr, $($args:tt)*) => {\n");
        output.push_str("        rust_i18n::t!($key, $($args)*)\n");
        output.push_str("    };\n");
        output.push_str("}\n");

        output
    }

    /// Generate const declarations for all translation keys
    fn generate_const_declarations(&self, flattened: &BTreeMap<String, String>) -> String {
        let mut output = String::new();

        for key in flattened.keys() {
            let const_name = self.key_to_const_name(key);
            let doc_comment = format!("/// Translation key: `{}`", key);

            output.push_str(&format!("{}\n", doc_comment));
            output.push_str(&format!("pub const {}: &str = \"{}\";\n\n", const_name, key));
        }

        output
    }

    /// Generate namespace modules for better organization
    fn generate_namespace_modules(&self, translations: &TranslationMap) -> String {
        let mut output = String::new();
        let namespaces = self.extract_namespaces(translations);

        for (namespace, keys) in namespaces {
            let module_name = self.sanitize_module_name(&namespace);

            output.push_str(&format!("/// {} namespace\n", namespace));
            output.push_str(&format!("pub mod {} {{\n", module_name));

            for key in keys {
                let const_name = self.key_to_const_name(&key);
                let full_key = format!("{}.{}", namespace, key);
                output.push_str(&format!("    /// Translation key: `{}`\n", full_key));
                output.push_str(&format!("    pub const {}: &str = \"{}\";\n", const_name, full_key));
            }

            output.push_str("}\n\n");
        }

        output
    }

    /// Extract namespaces from translations
    fn extract_namespaces(&self, translations: &TranslationMap) -> BTreeMap<String, Vec<String>> {
        let mut namespaces: BTreeMap<String, Vec<String>> = BTreeMap::new();

        for (key, value) in translations {
            if let TranslationValue::Nested(nested) = value {
                let nested_keys: Vec<String> = nested.keys().cloned().collect();
                namespaces.insert(key.clone(), nested_keys);
            }
        }

        namespaces
    }

    /// Convert a translation key to a Rust const name
    /// Example: "common.welcome" -> "COMMON_WELCOME"
    fn key_to_const_name(&self, key: &str) -> String {
        key.replace(['.', '-'], "_")
            .to_uppercase()
    }

    /// Sanitize module name for Rust
    fn sanitize_module_name(&self, name: &str) -> String {
        let sanitized = name
            .chars()
            .map(|c| if c.is_alphanumeric() { c } else { '_' })
            .collect::<String>()
            .to_lowercase();

        // Ensure it doesn't start with a number
        if let Some(first_char) = sanitized.chars().next() {
            if first_char.is_numeric() {
                return format!("_{}", sanitized);
            }
        }
        sanitized
    }
}

#[async_trait]
impl CodeGenerator for RustGenerator {
    async fn generate(
        &self,
        translations: &TranslationMap,
        language: &str,
        output_dir: &Path,
        options: GeneratorOptions,
    ) -> Result<GeneratorResult, GeneratorError> {
        let mut files_created = Vec::new();
        let keys_written = flatten_translations(translations).len() as u32;

        // Create output directory if it doesn't exist
        std::fs::create_dir_all(output_dir)?;

        // Generate keys module
        let keys_content = self.generate_consts(translations, language, &options);
        let keys_file = output_dir.join("keys.rs");
        std::fs::write(&keys_file, keys_content)?;
        files_created.push(keys_file);

        // Generate mod.rs if requested
        if options.create_index {
            let mod_content = "// Generated by ampel-i18n-builder\n\
                //! Translation key constants\n\n\
                pub mod keys;\n\n\
                pub use keys::*;\n";
            let mod_file = output_dir.join("mod.rs");
            std::fs::write(&mod_file, mod_content)?;
            files_created.push(mod_file);
        }

        Ok(GeneratorResult {
            files_created,
            languages_processed: 1,
            keys_written,
        })
    }

    fn file_extension(&self) -> &str {
        "rs"
    }

    fn language_name(&self) -> &str {
        "Rust"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_translations() -> TranslationMap {
        let mut translations = BTreeMap::new();
        translations.insert(
            "hello".to_string(),
            TranslationValue::String("Hello".to_string()),
        );

        let mut common = BTreeMap::new();
        common.insert(
            "welcome".to_string(),
            TranslationValue::String("Welcome".to_string()),
        );
        common.insert(
            "goodbye".to_string(),
            TranslationValue::String("Goodbye".to_string()),
        );
        translations.insert("common".to_string(), TranslationValue::Nested(common));

        let mut dashboard = BTreeMap::new();
        dashboard.insert(
            "title".to_string(),
            TranslationValue::String("Dashboard".to_string()),
        );
        translations.insert("dashboard".to_string(), TranslationValue::Nested(dashboard));

        translations
    }

    #[tokio::test]
    async fn test_rust_generator() {
        let generator = RustGenerator::new();
        let translations = create_test_translations();
        let output_dir = Path::new("/tmp/ampel-i18n-rust-test");

        let options = GeneratorOptions::default();
        let result = generator.generate(&translations, "en", output_dir, options).await;

        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.languages_processed, 1);
        assert!(result.keys_written >= 4);
        assert!(!result.files_created.is_empty());

        // Cleanup
        let _ = std::fs::remove_dir_all(output_dir);
    }

    #[test]
    fn test_generate_consts() {
        let generator = RustGenerator::new();
        let translations = create_test_translations();
        let options = GeneratorOptions {
            include_metadata: false,
            split_by_namespace: false,
            ..Default::default()
        };

        let consts = generator.generate_consts(&translations, "en", &options);
        assert!(consts.contains("pub const HELLO: &str = \"hello\""));
        assert!(consts.contains("pub const COMMON_WELCOME: &str = \"common.welcome\""));
        assert!(consts.contains("pub const DASHBOARD_TITLE: &str = \"dashboard.title\""));
        assert!(consts.contains("macro_rules! t"));
    }

    #[test]
    fn test_key_to_const_name() {
        let generator = RustGenerator::new();
        assert_eq!(generator.key_to_const_name("hello"), "HELLO");
        assert_eq!(generator.key_to_const_name("common.welcome"), "COMMON_WELCOME");
        assert_eq!(generator.key_to_const_name("app.name"), "APP_NAME");
        assert_eq!(generator.key_to_const_name("pull-requests"), "PULL_REQUESTS");
    }

    #[test]
    fn test_sanitize_module_name() {
        let generator = RustGenerator::new();
        assert_eq!(generator.sanitize_module_name("common"), "common");
        assert_eq!(generator.sanitize_module_name("dashboard"), "dashboard");
        assert_eq!(generator.sanitize_module_name("PullRequests"), "pullrequests");
        assert_eq!(generator.sanitize_module_name("123invalid"), "_123invalid");
    }

    #[test]
    fn test_extract_namespaces() {
        let generator = RustGenerator::new();
        let translations = create_test_translations();

        let namespaces = generator.extract_namespaces(&translations);
        assert_eq!(namespaces.len(), 2);
        assert!(namespaces.contains_key("common"));
        assert!(namespaces.contains_key("dashboard"));

        let common_keys = namespaces.get("common").unwrap();
        assert_eq!(common_keys.len(), 2);
        assert!(common_keys.contains(&"welcome".to_string()));
        assert!(common_keys.contains(&"goodbye".to_string()));
    }

    #[test]
    fn test_generate_namespace_modules() {
        let generator = RustGenerator::new();
        let translations = create_test_translations();

        let modules = generator.generate_namespace_modules(&translations);
        assert!(modules.contains("pub mod common {"));
        assert!(modules.contains("pub mod dashboard {"));
        assert!(modules.contains("pub const WELCOME: &str = \"common.welcome\""));
        assert!(modules.contains("pub const TITLE: &str = \"dashboard.title\""));
    }
}
